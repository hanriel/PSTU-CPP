# Лабораторная работа № 1 - Классы и объекты. Инкапсуляция.

## Цель работы

1. Создание консольного приложения, состоящего из нескольких файлов в системе программирования Visual Studio.
2. Использование классов и объектов в ОО программе.

## Постановка задачи

1. Реализовать определение нового класса. Для демонстрации работы с объектами написать главную функцию.
   Продемонстрировать разные способы создания объектов и массивов объектов.
2. Структура-пара – структура с двумя полями, которые обычно имеют имена first и second. Требуется реализовать тип
   данных с помощью такой структуры. Во всех заданиях должны присутствовать:
    1. метод инициализации Init (метод должен контролировать значения аргументов на корректность);
    2. ввод с клавиатуры Read;
    3. вывод на экран Show.
3. Реализовать внешнюю функцию make_тип(), где тип – тип реализуемой структуры. Функция должна получать значения для
   полей структуры как параметры функции и возвращать структуру как результат. При передаче ошибочных параметров следует
   выводить сообщение и заканчивать работу.

> Поле first – дробное число х, координата точки , поле second – дробное число y, координата точки. Реализовать метод
> distance(double x1, double y1) – вычисление расстояния от точки с координатами (first, second) до точки с
> координатами (
> x1,y1).

## Описание класса

Структура `point` состоит из двух атрибутов (`_x` и `_y`) типа `long`, и четырёх методов:

- `Init(double, double)` - для инициализации значений;
- `Read()` - ввод значений с клавиатуры;
- `Show()` - вывод на экран;
- `Distance(double, double)` - вычисление расстояния между двумя точками.

И имеет следующую UML диаграмму:

![UML-Diagram][uml-diagram]

## Определение компонентных функций

```c++
void point::Init(double X, double Y) {
	_x = X;
	_y = Y;
}
```

```c++
void point::Read() {
	cout << "X: ";
	cin >> _x;
	cout << "Y: ";
	cin >> _y;
}
```

```c++
void point::Show() {
	cout << "X: " << _x << endl;
	cout << "Y: " << _y << endl;
}
```

```c++
double point::Distance(double x1, double y1) {
	return sqrt(powf(x1 - _x, 2) + powf(y1 - _y, 2));
}
```

## Определение функции make...()

```c++
point make_point(double x, double y) {
    point p;
    p.Init(x, y);
    return p;
}
```

## Функция main()

```c++
int main()
{
    setlocale(LC_ALL, "rus");

    cout << "===Определение переменных A и B====" << endl;
    point A;
    point B;
    A.Init(3.0, 2.0);
    B.Read();
    A.Show();
    B.Show();
    cout << "A.Distance(" << B._x << ", " << B._y << ") = " << A.Distance(B._x, B._y) << endl;
    cout << "B.Distance(" << A._x << ", " << A._y << ") = " << B.Distance(A._x, A._y) << endl;

    cout << "\n=============Указатели=============" << endl;
    point* X = new point;
    X->Init(5, 6);
    X->Show();
    cout << "X.Distance(1, 1) = " << X->Distance(1, 1) << endl;

    cout << "Массивы" << endl;
    point mas[3];
    for (int i = 0; i < 3; i++)
        mas[i].Read();
    for (int i = 0; i < 3; i++)
        mas[i].Show();
    for (int i = 0; i < 3; i++)
        cout << "mas[" << i << "].Distance(0, 0) = " << mas[i].Distance(0, 0) << endl;

    cout << "\n=======Динамические массивы========" << endl;
    point* p_mas = new point[3];
    for (int i = 0; i < 3; i++)
        p_mas[i].Read();
    for (int i = 0; i < 3; i++)
        p_mas[i].Show();
    for (int i = 0; i < 3; i++)
        cout << "p_mas[" << i << "].Distance(0, 0) = " << mas[i].Distance(0, 0) << endl;

    cout << "\n====Вызов функции make_point()=====" << endl;
    double z, w;
    cout << "X: ";
    cin >> z;
    cout << "Y: ";
    cin >> w;
    point p = make_point(z, w);
    p.Show();

    return 0;
}
```

## Объяснение результатов работы программы

Результат работы программы:

```text
===Определение переменных A и B====
X: 2
Y: 2
X: 3
Y: 2
X: 2
Y: 2
A.Distance(2, 2) = 1
B.Distance(3, 2) = 1

=============Указатели=============
X: 5
Y: 6
X.Distance(1, 1) = 6.40312
Массивы
X: 6
Y: 5
X: 4
Y: 3
X: 2
Y: 1
X: 6
Y: 5
X: 4
Y: 3
X: 2
Y: 1
mas[0].Distance(0, 0) = 7.81025
mas[1].Distance(0, 0) = 5
mas[2].Distance(0, 0) = 2.23607

=======Динамические массивы========
X: 7
Y: 6
X: 5
Y: 4
X: 3
Y: 2
X: 7
Y: 6
X: 5
Y: 4
X: 3
Y: 2
p_mas[0].Distance(0, 0) = 7.81025
p_mas[1].Distance(0, 0) = 5
p_mas[2].Distance(0, 0) = 2.23607

====Вызов функции make_point()=====
X: 1
Y: 2
X: 1
Y: 2
```

## Ответы на контрольные вопросы

### 1. Что такое класс?

**Ответ:**
Класс является абстрактным типом данных, определяемым пользователем, и представляет собой модель реального объекта в
виде данных и функций для работы с ними.

```c++
class <имя> {
[ private: ]
    <описание скрытых элементов>
public:
    <описание доступных элементов>
}; // Описание заканчивается точкой с запятой
```

### 2. Что такое объект (экземпляр) класса?

**Ответ:**
Класс объявляется один раз, а переменных такого класса (объектов) может быть сколько угодно. Объявляются
такие переменные так же как и переменные встроенных типов:

```c++
Person p;
Person *pp;//указатель на переменную
Person Arr_p[10];//массив переменных
```

### 3. Как называются поля класса?

**Ответ:**
**Поле класса** или **aтрибут** — переменная, описание которой создает программист при создании класса

### 4. Как называются функции класса?

**Ответ:**
Классы имеют свои функции, которые называются методами класса.

### 5. Для чего используются спецификаторы доступа?

**Ответ:**
Спецификаторы доступа private и public управляют видимостью элементов класса. Элементы, описанные после служебного слова
private, видимы только внутри класса.

### 6. Для чего используется спецификатор public?

**Ответ:**
Спецификатор public делает члены класса - поля и функции открытыми, доступными из любой части программы.

### 7. Для чего используется спецификатор private?

**Ответ:**
Cпецификатор private делает члены закрытыми. Получить информацию о содержимом полей, описанных после спецификатора
private можно только с помощью специальных методов, которые называются селекторами, а изменить – с помощью методов,
которые называются модификаторами.

### 8. Если описание класса начинается со спецификатора class, то какой спецификатор доступа будет использоваться по умолчанию?

**Ответ:**
По умолчанию все методы и поля класса будут скрытыми (private).

### 9. Если описание класса начинается со спецификатора struct, то какой спецификатор доступа будет использоваться по умолчанию?

**Ответ:**
Все поля и методы по умолчанию будут общедоступными (public).

### 10. Какой спецификатор доступа должен использоваться при описании интерфейса класса? Почему?

**Ответ:**
Интерфейс класса описывается после спецификатора public.

### 11. Каким образом можно изменить значения атрибутов экземпляра класса?

**Ответ:**
Изменить информацию, содержащуюся в полях можно с помощью методов, которые называются модификаторами.

### 12. Каким образом можно получить значения атрибутов экземпляра класса?

**Ответ:**
Получить информацию о содержимом полей, описанных после спецификатора private можно только с помощью специальных
методов, которые называются селекторами.

### 13. Класс описан следующим образом

```c++
struct Student {
    string name;
    int group;
    ...
};
```

Объект класса определен следующим образом

```c++
Student *s=new Student;
```

Как можно обратиться к полю `name` объекта `s`?

**Ответ:**
Для обращения к полю `name` необходимо использовать оператор доступа к членам класса (->)

```c++
s->name;
```

### 14. Класс описан следующим образом

```c++
struct Student {
    string name;
    int group;
    ...
};
```

Объект класса определен следующим образом

```c++
Student s;
```

Как можно обратиться к полю `name` объекта `s`?

**Ответ:**
Для обращения к полю `name` необходимо использовать оператор доступа к членам класса (.)

```c++
s.name = "John";
```

### 15. Класс описан следующим образом

```c++
class Student {
    string name;
    int group;
    ...
};
```

Объект класса определен следующим образом

```c++
Student *s=new Student;
```

Как можно обратиться к полю `name` объекта `s`?

**Ответ:**
Для доступа к приватным полям `name` и `group` класса `Student` можно использовать открытые (публичные) методы, такие
как
модификаторы и селекторы. Селекторы позволяют получить значения приватных полей, а модификаторы - изменить их значения.

```c++
s->setName("John");
```

### 16. Класс описан следующим образом

```c++
class Student {
    string name;
    int group;
public:
    ...
};
```

Объект класса определен следующим образом

```c++
Student s;
```

Как можно обратиться к полю `name` объекта `s`?

**Ответ:**
Для доступа к приватным полям `name` и `group` класса `Student` можно использовать открытые (публичные) методы, такие
как
модификаторы и селекторы. Селекторы позволяют получить значения приватных полей, а модификаторы - изменить их значения.

```c++
s.setName("John");
```

### 17. Класс описан следующим образом

```c++
class Student {
public:
    char* name;
    int group;
    ...
};
```

Объект класса определен следующим образом

```c++
Student *s=new Student;
```

Как можно обратиться к полю `name` объекта `s`?

**Ответ:**
Для чтения значения поля `name` можно использовать следующий код:

```c++
char* studentName = s->name;
```

Для изменения значения поля `name` можно использовать следующий код:

```c++
s->name = "John";
```

---
Лабораторная работа доступна в GitHub репозитории [hanriel/PSTU-CPP](https://github.com/hanriel/PSTU-CPP/)

[uml-diagram]: ./assets/s2p1.svg "UML Diagram"
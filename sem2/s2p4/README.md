# Лабораторная работа № 4 - Простое наследование. Принцип подстановки.

## Цель работы

1. Создание консольного приложения, состоящего из нескольких файлов в системе
   программирования Visual Studio.
2. Создание иерархии классов с использованием простого наследования.
3. Изучение принципа подстановки.

## Постановка задачи

1. Определить пользовательский класс.
2. Определить в классе следующие конструкторы: без параметров, с параметрами,
   копирования.
3. Определить в классе деструктор.
4. Определить в классе компоненты-функции для просмотра и установки полей
   данных (селекторы и модификаторы).
5. Перегрузить операцию присваивания.
6. Перегрузить операции ввода и вывода объектов с помощью потоков.
7. Определить производный класс.
8. Написать программу, в которой продемонстрировать создание объектов и работу
   всех перегруженных операций.
9. Реализовать функции, получающие и возвращающие объект базового класса.
   Продемонстрировать принцип подстановки.

> Базовый класс:
> ТРОЙКА_ЧИСЕЛ (TRIAD)
> Первое_число (first) - int
> Второе_число (second) – int
> Третье_число (third) - int
> Определить методы изменения полей и сравнения триады. Создать производный класс TIME с полями часы, минуты и секунды.
> Определить полный набор операций сравнения временных промежутков.

## Описание класса

[//]: # (TODO Добавить описание класса)

![UML-Diagram][uml-diagram]

## Определение компонентных функций

```
// Constructors and destructor
Triad::Triad(void) { first = 0; second = 0; third = 0; }
Triad::Triad(int f, int s, int t) { first = f; second = s; third = t; }
Triad::Triad(const Triad& triad) { first = triad.first; second = triad.second; third = triad.third; }
Triad::~Triad(void) { }

// Setters
void Triad::setFirst(int f) { first = f; }
void Triad::setSecond(int s) { second = s; }
void Triad::setThird(int t) { third = t; }

// Getters
int Triad::getFirst() { return first; }
int Triad::getSecond() { return second; }
int Triad::getThird() { return third; }

Triad &Triad::operator = (const Triad &t) {
    if(&t == this) return *this;
    first = t.first;
    second = t.second;
    third = t.third;
}

istream &operator >> (istream &in, Triad &c) {
    cout << "FIRST: "; in>>c.first;
    cout << "SECOND: "; in>>c.second;
    cout << "THIRD: "; in>>c.third;
    return in;
}

ostream &operator << (ostream &out, Triad &c) {
    out << "\nFIRST : " << c.first;
    out << "\nSECOND : " << c.second;
    out << "\nTHIRD : " << c.third;
    out << "\n";
    return out;
}

bool Triad::operator<(const Triad &t) {
    return this->first == t.first ? this->second == t.second ? this->third < t.third :
            this->second < t.second :
            this->first < t.first;
}
 
bool Triad::operator==(const Triad &t) {
    return this->first == t.first
        && this->second == t.second
        && this->third == t.third;
}
```

```
bool TIME::operator!=(const Triad &other) {
    return !(*this == other);
}
```

## Определение глобальных функций

```
ostream &operator<<(std::ostream &out, const TIME &t) {
    return out << t.first << ':' << t.second << ':' << t.third;
}

istream &operator>>(istream &in, TIME &t) {
    cout << "Hours: "; in >> t.first;
    cout << "Minutes: "; in >> t.second;
    cout << "Minutes: "; in >> t.third;
    return in;
}
```

```
//Функция принимает обект базавого класса как параметр
void f1(Triad &t){
    t.setFirst(0);
}

//Функция возвращает обект базавого класса
Triad f2(){
    TIME t(12, 30, 0);
    return t;
}
```

## Функция main()

```
int main() {
    // Работа с классом TRIAD
    Triad a;
    cin >> a;
    cout << a;

    Triad b(12, 30, 45);
    cout << b;
    a=b;
    cout << a;

    // Работа с классом TIME
    TIME t;
    cin >> t;
    cout << t;

    // Принцип подстановки
    f1(t);
    a = f2();
    cout << a;

    return 0;
}
```

## Объяснение результатов работы программы

```
FIRST: 12
SECOND: 20
THIRD: 33

FIRST : 12
SECOND : 20
THIRD : 33

FIRST : 12
SECOND : 30
THIRD : 45

FIRST : 12
SECOND : 30
THIRD : 45
Hours: 10
Minutes: 20
Minutes: 40
10:20:40
FIRST : 12
SECOND : 30
THIRD : 0
```

## Ответы на контрольные вопросы
### 1. Для чего используется механизм наследования?
**Ответ:** 
Механизм наследования в C++ используется для создания новых классов, которые наследуют свойства и методы от существующих классов (родительских классов). Это позволяет создавать иерархию классов, упрощая разработку и обслуживание программного кода.

Когда класс наследуется от другого класса, он получает все свойства и методы родительского класса. При этом наследующий класс может изменять и дополнять свойства и методы базового класса. Таким образом, механизм наследования позволяет повторно использовать код, упрощая разработку и сокращая количество дублирования кода.

Также механизм наследования позволяет использовать полиморфизм, что позволяет работать с объектами наследников как с объектами базового класса. Это дает возможность упрощать код, упрощать обслуживание и расширение программного кода, а также повышать его производительность.

### 2. Каким образом наследуются компоненты класса, описанные со спецификатором public?
**Ответ:** 
Компоненты класса, описанные со спецификатором public, наследуются производным классом таким же способом, как и любые другие компоненты класса.

При наследовании производный класс получает все публичные компоненты базового класса, включая его поля данных, методы и конструкторы. Эти компоненты становятся доступными в рамках производного класса и могут быть использованы в его методах и конструкторах.

Наследование со спецификатором public означает, что публичные компоненты базового класса будут доступны не только внутри производного класса, но и снаружи. Это позволяет использовать производный класс как заменитель базового класса в любом контексте, где требуется объект базового класса.

### 3. Каким образом наследуются компоненты класса, описанные со спецификатором private?
**Ответ:** 
Компоненты класса, описанные со спецификатором private, не наследуются производным классом и не доступны внутри производного класса.

При наследовании производный класс получает все публичные и защищенные компоненты базового класса. Однако, компоненты, описанные со спецификатором private, не доступны внутри производного класса и не могут быть использованы в его методах и конструкторах.

Если производный класс пытается обратиться к приватному компоненту базового класса, то это приведет к ошибке компиляции. Поэтому, если производный класс нуждается в доступе к приватным компонентам базового класса, то можно использовать защищенные компоненты, которые будут доступны внутри производного класса.

### 4. Каким образом наследуются компоненты класса, описанные со спецификатором protected?
**Ответ:** 
Компоненты класса, описанные со спецификатором protected, наследуются производным классом и доступны внутри производного класса и его наследников.

При наследовании производный класс получает все публичные и защищенные компоненты базового класса. Эти компоненты становятся доступными в рамках производного класса и могут быть использованы в его методах и конструкторах. Кроме того, компоненты, описанные со спецификатором protected, могут быть доступны внутри производных классов, которые наследуют производный класс.

Наследование со спецификатором protected означает, что защищенные компоненты базового класса будут доступны только внутри производного класса и его наследников. Это позволяет использовать производный класс как базовый класс для других классов, которые будут иметь доступ к его защищенным компонентам.

### 5. Каким образом описывается производный класс?
**Ответ:** 
Для описания производного класса в C++ используется ключевое слово "class" или "struct", за которым следует имя производного класса и двоеточие, после которого указывается имя базового класса, от которого производится наследование. Например:

```
class DerivedClass : public BaseClass {
    // тело класса
};
```

Здесь "DerivedClass" - имя производного класса, "BaseClass" - имя базового класса, от которого производится наследование, и ключевое слово "public" указывает на тип доступа к наследованным членам базового класса (в данном случае - открытый доступ). 

При наследовании производный класс получает все члены базового класса, кроме конструкторов, деструкторов и операторов присваивания, которые могут быть переопределены в производном классе. Также в производном классе можно добавлять свои собственные члены.

### 6. Наследуются ли конструкторы?
**Ответ:** 
При наследовании в C++ конструкторы базового класса не наследуются автоматически в производный класс. Однако, при создании объекта производного класса, конструктор базового класса будет вызван автоматически перед вызовом конструктора производного класса.

Если в производном классе не определен конструктор, то компилятор C++ автоматически сгенерирует конструктор по умолчанию, который вызовет конструктор по умолчанию базового класса.

Если же в производном классе определен конструктор, то необходимо явно вызвать конструктор базового класса в списке инициализации конструктора производного класса, например:

```
class DerivedClass : public BaseClass {
public:
    DerivedClass(int derivedArg, int baseArg) : BaseClass(baseArg) {
        // тело конструктора производного класса
    }
};
```

В этом примере конструктор производного класса принимает два аргумента, один из которых передается в конструктор базового класса с помощью списка инициализации.
### 7. Наследуются ли деструкторы?
**Ответ:** 
При наследовании в C++ деструкторы базового класса наследуются в производный класс, но они не вызываются автоматически при удалении объекта производного класса.

Для вызова деструктора базового класса необходимо явно вызвать его в деструкторе производного класса, используя оператор "delete", например:

```
class DerivedClass : public BaseClass {
public:
    ~DerivedClass() {
        // тело деструктора производного класса
        delete baseClassObject;
    }
private:
    BaseClass* baseClassObject;
};
```

В этом примере деструктор производного класса удаляет объект базового класса с помощью оператора "delete", чтобы вызвать его деструктор.

Если базовый класс имеет виртуальный деструктор, то в производном классе также необходимо определить виртуальный деструктор, чтобы обеспечить правильное удаление объекта при использовании указателя на базовый класс. Например:

```
class BaseClass {
public:
    virtual ~BaseClass() {}
};

class DerivedClass : public BaseClass {
public:
    virtual ~DerivedClass() {}
};
```

В этом примере и базовый, и производный класс имеют виртуальные деструкторы, что обеспечивает корректное удаление объекта при использовании указателя на базовый класс.

### 8. В каком порядке конструируются объекты производных классов?
**Ответ:** 
При создании объекта производного класса в C++ сначала вызывается конструктор базового класса, а затем конструктор производного класса.

Если в производном классе определен конструктор, то он должен вызывать конструктор базового класса в списке инициализации, например:

```
class BaseClass {
public:
    BaseClass(int arg) {
        // тело конструктора базового класса
    }
};

class DerivedClass : public BaseClass {
public:
    DerivedClass(int derivedArg, int baseArg) : BaseClass(baseArg) {
        // тело конструктора производного класса
    }
};
```

В этом примере конструктор производного класса вызывает конструктор базового класса с помощью списка инициализации, передавая ему значение аргумента "baseArg".

Если в производном классе не определен конструктор, то компилятор C++ автоматически сгенерирует конструктор по умолчанию, который вызовет конструктор по умолчанию базового класса.

Если в классе определены статические члены данных, то они инициализируются до вызова конструктора. При этом порядок инициализации статических членов данных зависит от порядка их объявления в классе.

### 9. В каком порядке уничтожаются объекты производных классов?
**Ответ:** 
При удалении объекта производного класса в C++ сначала вызывается деструктор производного класса, а затем деструктор базового класса.

Если в производном классе определен деструктор, то он должен вызывать деструктор базового класса в теле деструктора, например:

```
class BaseClass {
public:
    ~BaseClass() {
        // тело деструктора базового класса
    }
};

class DerivedClass : public BaseClass {
public:
    ~DerivedClass() {
        // тело деструктора производного класса
    }
};
```

В этом примере деструктор производного класса вызывает деструктор базового класса автоматически при своем завершении.

Если в классе определены статические члены данных, то они уничтожаются в обратном порядке их инициализации при завершении программы. При этом порядок уничтожения статических членов данных зависит от порядка их объявления в классе.
### 10. Что представляют собой виртуальные функции и механизм позднего связывания?
**Ответ:** 
В C++ виртуальные функции позволяют реализовывать полиморфизм, то есть использование функций базового класса для работы с объектами производных классов. При вызове виртуальной функции у объекта производного класса вызывается соответствующая функция этого класса, а не функция базового класса.

Механизм позднего связывания (late binding) основан на использовании виртуальных функций и позволяет отложить определение вызываемой функции до времени выполнения программы. При этом компилятор не знает точного типа объекта, на котором будет вызвана виртуальная функция, поэтому адрес вызываемой функции будет определен только в момент выполнения программы.

### 11. Могут ли быть виртуальными конструкторы? Деструкторы?
**Ответ:** 
Да, в C++ могут быть виртуальные конструкторы и деструкторы. 

Виртуальный конструктор позволяет создавать объекты производного класса с помощью указателя на базовый класс. Для этого в базовом классе нужно объявить конструктор как виртуальный, а в производных классах переопределить его. 

Виртуальный деструктор позволяет правильно освободить память при удалении объекта через указатель на базовый класс. Для этого в базовом классе нужно объявить деструктор как виртуальный. 

### 12. Наследуется ли спецификатор virtual?
**Ответ:** 
Да, спецификатор `virtual` наследуется в C++. Если функция в базовом классе объявлена как `virtual`, то она автоматически становится виртуальной и в производных классах. Это означает, что если производный класс переопределяет эту функцию, то он может использовать спецификатор `override`, чтобы явно указать, что функция является виртуальной и переопределена.

### 13. Какое отношение устанавливает между классами открытое наследование?
**Ответ:** 
Открытое наследование в C++ устанавливает отношение "является" между базовым и производным классами. Это означает, что производный класс является расширением базового класса и наследует все его члены (поля, методы, конструкторы и деструкторы). 

### 14. Какое отношение устанавливает между классами закрытое наследование?
**Ответ:** 
Закрытое наследование в C++ устанавливает отношение "реализуется в терминах" между базовым и производным классами. Это означает, что производный класс реализует интерфейс базового класса и наследует все его члены, но не может напрямую обращаться к ним из своего кода. 

### 15. В чем заключается принцип подстановки?
**Ответ:** 
Принцип подстановки (Liskov substitution principle) - это один из принципов объектно-ориентированного программирования, который определяет, как должны вести себя производные классы в отношении своих базовых классов. 

Согласно принципу подстановки, объекты производного класса должны быть полностью совместимы с объектами базового класса, т.е. они должны сохранять все свойства и поведение базового класса. Это означает, что объекты производного класса должны:

- иметь тот же интерфейс (методы и свойства), что и объекты базового класса;
- выполнять те же действия, что и объекты базового класса, без изменения их поведения;
- удовлетворять тем же предусловиям и постусловиям, что и объекты базового класса.

Принцип подстановки является важным для обеспечения гибкости и расширяемости кода, поскольку он позволяет использовать объекты производного класса вместо объектов базового класса, не изменяя поведения программы.

### 16. Имеется иерархия классов:

```
class Student {
    int age;
public:
    string name;
    ...
};

class Employee : public Student {
protected:
    string post;
    ...
};

class Teacher : public Employee {
protected:
    int stage;
    ...
};
Teacher x;
```

Какие компонентные данные будет иметь объект х?

**Ответ:**
Объект x будет иметь компонентные данные, унаследованные от классов Student, Employee и Teacher:

- age (из класса Student)
- name (из класса Student)
- post (из класса Employee)
- stage (из класса Teacher)

[//]: # (TODO Доответить на контрольные вопросы)

### 17. Для классов Student, Employee и Teacher написать конструкторы без параметров.

**Ответ:**

### 18. Для классов Student, Employee и Teacher написать конструкторы с параметрами.

**Ответ:**

### 19. Для классов Student, Employee и Teacher написать конструкторы копирования.

**Ответ:**

### 20. Для классов Student, Employee и Teacher определить операцию присваивания.

**Ответ:** 

[uml-diagram]: ./assets/uml-diagram.svg "UML Diagram"

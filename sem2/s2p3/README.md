# Лабораторная работа №3 - "Перегрузка операций"

## Цель:

1. Создание консольного приложения, состоящего из нескольких файлов в системе
   программирования Visual Studio.
2. Использование перегруженных операций в классах.

## Постановка задачи

1. Определить пользовательский класс.
2. Определить в классе следующие конструкторы: без параметров, с параметрами,
   копирования.
3. Определить в классе деструктор.
4. Определить в классе компоненты-функции для просмотра и установки полей
   данных (селекторы и модификаторы).
5. Перегрузить операцию присваивания.
6. Перегрузить операции ввода и вывода объектов с помощью потоков.
7. Перегрузить операции указанные в варианте.
8. Написать программу, в которой продемонстрировать создание объектов и работу
   всех перегруженных операций.

> Создать класс Money для работы с денежными суммами. Число должно быть представлено двумя полями: типа long для рублей
> и типа int для копеек. Дробная часть числа при выводе на экран должна быть отделена от целой части запятой. Реализовать:
> - вычитание дробного числа из суммы
> - операции сравнения (==, !=).

## Описание класса

Класс `Money` состоит из двух атрибутов:

- rub : long - рубли
- cheers : int - копейки

Конструктора **без параметров, с параметрами, копирования и деструктора.**

Методов:

- `getRub() : long` - селектор атрибута rub (рубли)
- `getCheers() : int` - селектор атрибута cheers (копейки)
- `setRub(long) : void` - модификатор атрибута rub (рубли)
- `setCheers(int) : void` - модификатор атрибута cheers (копейки)

Перегружаемых операторов:

- `operator=(const Money&) : Money&` - оператор приваивания
- `operator==(const Money&) : bool` - оператор сравнения (равно)
- `operator!=(const Money&) : bool` - оператор сравнения (не равно)
- `operator-(const Money&, const Money&) : Money` - оператор разности
- `&operator>>(istream&, Money&) : istream` - костомные функции ввода
- `&operator<<(ostream&, const Money&) : ostream` - кастомные функции вывода

И имеет следующую UML диаграмму:


![UML-Diagram][uml-diagram]

## Определение компонентных функций

```
Money::Money() { rub = 0; cheers = 0; }

Money::Money(long r, int c) {
    rub = (r * 100 + c) / 100; cheers = c;
    cheers = (r * 100 + c) % 100;
}

Money::Money(const Money& m) { rub = m.rub; cheers = m.cheers; }

Money::~Money() { }

long Money::getRub() { return rub; }
int Money::getCheers() { return cheers; }
void Money::setRub(long r) { rub = r;  }
void Money::setCheers(long c) { cheers = c; }

// перегрузка операции присваивания
Money& Money::operator=(const Money &m) {
    if(&m==this) return *this;
    rub = m.rub;
    cheers = m.cheers;
    return *this;
}

// перегрузка операций сравнения
bool Money::operator==(const Money& other) {
    return (this->rub == other.rub && this->cheers == other.cheers);
}

bool Money::operator!=(const Money& other) {
    return !(*this == other);
}

// перегрузка операции вычитания
Money operator-(const Money& lhs, const Money& rhs) {
    Money obj(lhs.rub - rhs.rub, lhs.cheers - rhs.cheers);
    return obj;
}
```

## Определение глобальных функций

```
// перегрузка глобальной функции-операции ввода
istream& operator>>(istream&in, Money&m) {
    cout<<"rub?"; in>>m.rub;
    cout<<"cheers?"; in>>m.cheers;
    return in;
}
// перегрузка глобальной функции-операции вывода
ostream& operator<<(ostream&out, const Money&m) {
    return (out<<m.rub<<","<< setfill('0') << setw(2) << m.cheers) << "rub";
}
```

## Функция main()

```
int main() {
    // конструкторы без параметров
    Money a;
    Money b;
    Money c;

    // ввод переменных
    cin >> a;
    cin >> b;

    // разность
    c = a - b;

    // вывод переменной
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
    cout<<"c="<<c<<endl;

    return 0;
}
```

## Объяснение результатов работы программы

```
rub?25
cheers?15
rub?10
cheers?3
a=25,15rub
b=10,03rub
c=15,12rub
```

## Ответы на контрольные вопросы

### 1. Для чего используются дружественные функции и классы?

**Ответ:** Дружественные функции применяются для доступа к скрытым полям класса и представляют собой альтернативу
методам

### 2. Сформулировать правила описания и особенности дружественных функций.

**Ответ:**

- Дружественная функция объявляется внутри класса, к элементам которого ей нужен доступ, с ключевым словом `friend`. В
  качестве параметра ей должен передаваться объект или ссылка на объект класса, поскольку указатель `this` ей не
  передается.
- Дружественная функция может быть обычной функцией или методом другого ранее определенного класса. На нее не
  распространяется действие спецификаторов доступа, место размещения ее объявления в классе безразлично.
- Одна функция может быть дружественной сразу нескольким классам.

### 3. Каким образом можно перегрузить унарные операции?

**Ответ:**  Унарную операцию можно перегрузить:

- Как компонентную функцию класса
- Как внешнюю (глобальную) функцию

### 4. Сколько операндов должна иметь унарная функция-операция, определяемая внутри класса?

**Ответ:** должна быть представлена с помощью нестатического метода без параметров, при этом операндом является
вызвавший ее объект

```
Person& operator ++() {
    ++age;
    return *this;
}
```

### 5. Сколько операндов должна иметь унарная функция-операция, определяемая вне класса?

**Ответ:** должна иметь один параметр, тип класса

```
Person &operator ++(Person& p) {
    ++p.age;
    return p;
}
```

### 6. Сколько операндов должна иметь бинарная функция-операция, определяемая внутри класса?

**Ответ:** должна быть представлена с помощью нестатического метода с параметрами, при этом вызвавший ее объект
считается первым операндом

```
Person & operator+(int x) {
    age+=x;
    return *this;
}
```

### 7. Сколько операндов должна иметь бинарная функция-операция, определяемая вне класса?

**Ответ:**  Если функция определяется вне класса, она должна иметь два параметра типа класса

```
Person & operator +(Person &p, int x)
{
p.age+=x;
return p;
}
```

### 8. Чем отличается перегрузка префиксных и постфиксных унарных операций?

**Ответ:** Операции постфиксного инкремента и декремента должны иметь первый параметр типа int. Он используется только
для того, чтобы отличить их от префиксной формы.

### 9. Каким образом можно перегрузить операцию присваивания?

**Ответ:** Операция присваивания определена в любом классе по умолчанию как поэлементное копирование. Эта операция
вызывается каждый раз, когда одному существующему объекту присваивается значение другого.

```
Person& Person::operator = (const& Person p) {
    if (&p==this) return *this;
    name = p.name;
    age = p.age;
    return *this;
}
```

### 10. Что должна возвращать операция присваивания?

**Ответ:** Чтобы сохранить семантику присваивания, операция-функция должна возвращать ссылку на объект, для которого она
вызвана, и принимать в качестве параметра единственный аргумент — ссылку на присваиваемый объект.

### 11. Каким образом можно перегрузить операции ввода-вывода?

**Ответ:** Операции ввода-вывода operator>> и operator<< всегда реализуются как внешние дружественные функции, т. к.
левым операндом этих операций являются потоки.

```
istream &operator>>(istream &in, Person &p) {
    cout<<"name?"; in>>p.name;
    cout<<"age?"; in>>p.age;
    return in;
}

ostream &operator<<(ostream &out, const Person &p) {
    return (out<<p.name<<","<<p.age);
}
```

### 12. В программе описан класс

```
class Student {
    ...
    Student& operator++();
    ...
};
```

и определен объект этого класса

```
Student s;
```

Выполняется операция `++s;`

Каким образом, компилятор будет воспринимать вызов функции-операции?
**Ответ:**

### 13. В программе описан класс

```
class Student {
    ...
    friend Student& operator ++( Student&);
    ...
};
```

и определен объект этого класса

```
Student s;
```

Выполняется операция `++s;`

Каким образом, компилятор будет воспринимать вызов функции-операции?
**Ответ:**

### 14. В программе описан класс

```
class Student {
    ...
    bool operator<(Student &P);
    ...
};
```

и определены объекты этого класса

```
Student a,b;
```

Выполняется операция `cout<<a<b;`

Каким образом, компилятор будет воспринимать вызов функции-операции?
**Ответ:**

### 15. В программе описан класс

```
class Student {
    ...
    friend bool operator >(const Person&, Person&)
    ...
};
```

и определены объекты этого класса

```
Student a,b;
```

Выполняется операция `cout<<a>b;`

Каким образом, компилятор будет воспринимать вызов функции-операции?
**Ответ:**

[uml-diagram]: ./assets/s2p3.svg "UML Diagram"
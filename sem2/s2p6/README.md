# Лабораторная работа № 6 - "АТД. Контейнеры"

## Цель работы

1. Создание консольного приложения, состоящего из нескольких файлов в системе программирования Visual Studio.
2. Реализация класса-контейнера.

## Постановка задачи

1. Определить класс-контейнер.
2. Реализовать конструкторы, деструктор, операции ввода-вывода, операцию присваивания.
3. Перегрузить операции, указанные в варианте.
4. Реализовать класс-итератор. Реализовать с его помощью операции последовательного доступа.
5. Написать тестирующую программу, иллюстрирующую выполнение операций.

> Класс- контейнер МНОЖЕСТВО с элементами типа int.
> Реализовать операции:
>
> [] – доступа по индексу;
>
> != - проверка на неравенство;
>
> < число – принадлежность числа множеству;
>
> +n – переход вправо к элементу с номером n ( с помощью класса-итератора).

## Описание класса-контейнера

```c++
// Множество
class Array {
public:
explicit Array(int s, int k = 0);

    Array(const Array &a);

    ~Array();

    Array &operator=(const Array &a);     //оператор присваивания
    int &operator[](int index); //операция доступа по индексу
    Array operator+(const int k);
    int operator()(); //операция, возвращающая длину множества
    friend ostream &operator<<(ostream &out, const Array &a); //перегруженные операции ввода-вывода
    friend istream &operator>>(istream &in, Array &a);

    Iterator first() { return beg; }//возвращает указатель на первый элемент
    Iterator last() { return end; }//возвращает указатель на элемент следующий за
private:
int size;//размер множества
int *data;//укзатель на динамический массив значений множества
Iterator beg;//указатель на первый элемент множества
Iterator end;//указатель на элемент следующий за последним
};
```

## Определение компонентных функций

```c++
Array::Array(int s, int k) {
    size = s;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = k;
    beg.elem = &data[0];
    end.elem = &data[size];
}

//конструктор копирования
Array::Array(const Array &a) {
    size = a.size;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = a.data[i];
    beg = a.beg;
    end = a.end;
}

//деструктор
Array::~Array() {
    delete[]data;
    data = 0;
}

//операция присваивания
Array &Array::operator=(const Array &a) {
    if (this == &a)return *this;
    size = a.size;
    if (data != 0) delete[]data;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = a.data[i];
    beg = a.beg;
    end = a.end;
    return *this;
}

//операция доступа по индексу
int &Array::operator[](int index) {
    if (index < size) return data[index];
    else cout << "\nError! Index>size";
}

//операция для получения длины множества
int Array::operator()() {
    return size;
}

//операции для ввода-выода
ostream &operator<<(ostream &out, const Array &a) {
    for (int i = 0; i < a.size; ++i)
        out << a.data[i] << " ";
    return out;
}

istream &operator>>(istream &in, Array &a) {
    for (int i = 0; i < a.size; ++i)
        in >> a.data[i];
    return in;
}

//операция для добавления константы
Array Array::operator+(const int k)//+k
{
    Array temp(size);
    for (int i=0;i<size;++i)
        temp.data[i]+=data[i]+k;
    return temp;
}
```

## Описание класса-итератора и его компонентных функций

```c++
class Iterator {
    friend class Array;                     //дружественный класс
public:
    Iterator() { elem = nullptr; }               //конструктор без параметров
    Iterator(const Iterator &it) { elem = it.elem; }//конструктор копирования
    //перегруженные операции сравнения
    bool operator==(const Iterator &it) { return elem == it.elem; }
    bool operator!=(const Iterator &it) { return elem != it.elem; };

    void operator++(int) { ++elem; };            //перегруженная операция инкремент
    void operator--(int) { --elem; }              //перегруженная операция декремент
    int &operator*() const { return *elem; }  //перегруженная операция разыменования
private:
    int *elem;                               //указатель на элемент типа int
};
```

## Функция main()

```c++
int main() {
    Array a(5);         //создали множество из 5 элементов, заполненный нулями
    cout << a << "\n";      //вывели значения элементов множества
    cin >> a;             //ввели с клавиатуры значения элементов множества
    cout << a << "\n";      //вывели значения элементов множества
    a[2] = 100;           //используя операцию [] присвоили новое значение элементу
    cout << a << "\n";      //вывели значения элементов множества
    Array b(10);        //создали множество b из 10 элементов, заполненный нулями
    cout << b << "\n";      //вывели значения элементов множества
    b = a;                //присвоили множеству b значения множества a
    cout << b << "\n";      //вывели значения элементов множества
    Array c(10);        //создали множество c из 10 элементов, заполненный нулями
    c = b + 100;            //Увеличили значения множества b на 100 и присвоили множеству c
    cout << c << "\n";      //вывели значения элементов множества c
    cout << "\nthe length of a=" << a() << endl;//вывели длину множества a
    //разыменовываем значение, которое возвращает a.first() и выводим его
    cout << *(a.first()) << endl;
    //переменную типа Iterator устанавливаем на первый элемент множества а с
    //помощью метода first
    Iterator i = a.first();
    //оперция инкремент
    i++;
    //разыменовываеи итератор и выводи его значение
    cout << *i << endl;
    //выводим значения элеменов множества с помощью итератора
    for (i = a.first(); i != a.last(); i++)cout << *i << endl;
    return 0;
}
```

## Объяснение результатов работы программы

```
<< 0 0 0 0 0 
>> 0
>> 0
>> 0
>> 0
>> 0
<< 0 0 0 0 0 
<< 0 0 100 0 0 
<< 0 0 0 0 0 0 0 0 0 0 
<< 0 0 100 0 0 
<< 100 100 200 100 100 
<< 
<< the length of a=5
<< 0
<< 0
<< 0
<< 0
<< 100
<< 0
<< 0

Process finished with exit code 0
```

## Ответы на контрольные вопросы

### 1. Какой метод называется чисто виртуальным? Чем он отличается от виртуального метода?

**Ответ:**

### 1. Что такое абстрактный тип данных? Привести примеры АТД.x

**Ответ:**

### 2. Привести примеры абстракции через параметризацию.

**Ответ:**

### 3. Привести примеры абстракции через спецификацию.

**Ответ:**

### 4. Что такое контейнер? Привести примеры.

**Ответ:**

### 5. Какие группы операций выделяют в контейнерах?

**Ответ:**

### 6. Какие виды доступа к элементам контейнера существуют? Привести примеры.

**Ответ:**

### 7. Что такое итератор?

**Ответ:**

### 8. Каким образом может быть реализован итератор?

**Ответ:**

### 9. Каким образом можно организовать объединение контейнеров?

**Ответ:**

### 10. Какой доступ к элементам предоставляет контейнер, состоящий из элементов «ключ-значение»?

**Ответ:**

### 11. Как называется контейнер, в котором вставка и удаление элементов выполняется на одном конце контейнера?

**Ответ:**

### 12. Какой из объектов (a,b,c,d) является контейнером?

    a. int mas=10;
    b. 2. int mas;
    c. 3. struct {char name[30]; int age;} mas;
    d. 4. int mas[100];

**Ответ:**

### 13. Какой из объектов (a,b,c,d) не является контейнером?

    a. int a[]={1,2,3,4,5};b. 2. int mas[30];
    c. 3. struct {char name[30]; int age;} mas[30];
    d. 4. int mas;

**Ответ:**

### 14. Контейнер реализован как динамический массив, в нем определена операция доступ по индексу. Каким будет доступ к элементам контейнера?

**Ответ:**

### 15. Контейнер реализован как линейный список. Каким будет доступ к элементам контейнера?

**Ответ:** 

---
Лабораторная работа доступна в GitHub репозитории [hanriel/PSTU-CPP](https://github.com/hanriel/PSTU-CPP/)


# Лабораторная работа № 2 - Классы и объекты. Использование конструкторов.

## Цель работы

1. Создание консольного приложения, состоящего из нескольких файлов в системе
   программирования Visual Studio.
2. Создание объектов с использованием конструкторов.

## Постановка задачи

1. Определить пользовательский класс.
2. Определить в классе следующие конструкторы: без параметров, с параметрами,
   копирования.
3. Определить в классе деструктор.
4. Определить в классе компоненты-функции для просмотра и установки полей
   данных (селекторы и модификаторы).
5. Написать демонстрационную программу, в которой продемонстрировать все три
   случая вызова конструктора-копирования, вызов конструктора с параметрами и
   конструктора без параметров.

>       Пользовательский класс СОТРУДНИК
>       ФИО – string
>       Должность – string
>       Зарплата – double

## Описание класса

Класс `Emplyee` состоит из трех атрибутов:

- `fio : string` - ФИО сотредник;
- `post : string` - Должность сотрудника;
- `salary : double` - Зарплата.

Трех конструкторов: **без параметров, с параметрами, копирования;
Деструктора;**

И семи методов:

- `getFIO()` - получить значение атрибута ФИО
- `setFIO(string)` - установить значение атрибута ФИО
- `getPost()` - получить значение атрибута Должность
- `setPost(string)` - установить значение атрибута
- `getSalary()` - получить значение аитрибута Зарплата
- `setSalary(double)` - установить значение атрибута
- `show()` - просмотр значений атрибутов

и имеет следующую UML диаграмму:

![UML-Diagram][uml-diagram]

## Определение компонентных функций

```
// Конструктор без параметров
Employee::Employee() {
	fio = ""; post = ""; salary = 0;
	cout << "====Конструктор без параметров====" << endl;
}

// Конструктор c параметрами
Employee::Employee(string _fio, string _post, double _salary) {
	fio = _fio;	post = _post; salary = _salary;
	cout << "===Конструктор c параметрами===" << endl;
}

// Конструктор копирования
Employee::Employee(const Employee &e) {
	fio = e.fio; post = e.post; salary = e.salary;
	cout << "===Конструктор копирования===" << endl;
}

// Деструктор
Employee::~Employee() {	cout << "Деструктор: " << this << endl; }

// Селекторы
string Employee::getFIO() {	return fio; }
string Employee::getPost() { return post; }
double Employee::getSalary() { return salary; }

// Модификаторы
void Employee::setFIO(string _fio) { fio = _fio; }
void Employee::setPost(string _post) { post = _post; }
void Employee::setSalary(double _salary) { salary = _salary; }

// Метод для просмтра атрибутов
void Employee::show() {
	cout << "" << fio << endl;
	cout << "" << post << endl;
	cout << "" << salary << endl;
}
```

## Определение функции make_() и print_()

```
Employee makeEmployee() {
    string fio;
    string post;
    double salary;

    cout << "Введите ФИО: ";
    cin >> fio;
    cout << "Введите Должность: ";
    cin >> post;
    cout << "Введите Зарплату: ";
    cin >> salary;

    Employee e(fio, post, salary);
    return e;
}

// Функция для передачи объекта как параметра
void printEmployee(Employee e) {
    e.show();
}
```

## Функция main()

```
int main()
{
    setlocale(LC_ALL, "rus");

    Employee e1;
    e1.show();

    Employee e2("Федосеев Данил Александрович", "Преподаватель", 20000);
    e2.show();

    Employee e3 = e2;
    e3.setFIO("Гибадуллин Дамир Рустамович");
    e3.setPost("Преподаватель");
    e3.setSalary(25000);

    printEmployee(e3);

    e1 = makeEmployee();
    e1.show();

    return 0;
}
```

## Объяснение результатов работы программы

```
====Конструктор без параметров====


0
===Конструктор c параметрами===
Федосеев Данил Александрович
Преподаватель
20000
===Конструктор копирования===
===Конструктор копирования===
Гибадуллин Дамир Рустамович
Преподаватель
25000
Деструктор для класса: 0x7ffeab6d9eb0
Введите ФИО: ВеселковЕгорПавлович            
Введите Должность: Директор
Введите Зарплату: 30000
===Конструктор c параметрами===
Деструктор для класса: 0x7ffeab6d9f00
ВеселковЕгорПавлович
Директор
30000
Деструктор для класса: 0x7ffeab6d9d00
Деструктор для класса: 0x7ffeab6d9d50
Деструктор для класса: 0x7ffeab6d9da0
```

## Ответы на контрольные вопросы

### 1. Для чего нужен конструктор?

**Ответ:**
**Конструктор** - это метод, который предназначен для инициализации объекта. Его имя совпадает с именем класса, и он
вызывается автоматически при инициализации объекта.

### 2. Сколько типов конструкторов существует в С++?

Существует три типа конструкторов:

- **конструктор с параметрами**, используется для инициализации объекта требуемыми
  значениями;
- **конструктор без параметров**, используется для создания «пустого» объекта;
- **конструктор копирования**, используется для создания объекта, аналогичного тому,
  который уже существует.

### 3. Для чего используется деструктор? В каких случаях деструктор описывается явно?

**Ответ:** Деструктор – это особый вид метода, применяющийся для освобождения ресурсов, выделенных конструктором
объекту. Деструктор вызывается автоматически, когда объект удаляется из памяти.

Описывать в классе деструктор явным образом требуется в случае, когда объект
содержит указатели на память, выделяемую динамически — иначе при уничтожении
объекта память, на которую ссылались его поля-указатели, не будет помечена как свободная.

### 4. Для чего используется конструктор без параметров? Конструктор с параметрами? Конструктор копирования?

**Ответ:**

- Конструктор без параметров, используется для создания «пустого» объекта.
- Конструктор с параметрами, используется для инициализации объекта требуемыми
  значениямиё
- Конутрутор копирования, выполняет поэлементное копирование полей

### 5. В каких случаях вызывается конструктор копирования?

**Ответ:** Конструктор копирования вызывается в тех случаях, когда новый объект создается путем
копирования существующего:

- при описании нового объекта с инициализацией другим объектом;
- при передаче объекта в функцию по значению;
- при возврате объекта из функции.

### 6. Перечислить свойства конструкторов.

**Ответ:**

- Конструктор не возвращает значение, даже типа void. Нельзя получить указатель на
  конструктор.
- Класс может иметь несколько конструкторов с разными параметрами для разных
  видов инициализации.
- Конструктор, вызываемый без параметров, называется конструктором по умолчанию.
- Параметры конструктора могут иметь любой тип, кроме этого же класса.
- Если программист не указал ни одного конструктора, компилятор создает его
  автоматически.
- Конструкторы не наследуются.
- Конструкторы нельзя описывать с модификаторами const, virtual и static.
- Конструкторы глобальных объектов вызываются до вызова функции main.
- Конструктор вызывается, если в программе встретилась какая-либо из синтаксических конструкций

### 7. Перечислить свойства деструкторов.

**Ответ:**

- не имеет аргументов и возвращаемого значения;
- не наследуется;
- не может быть объявлен как const или static (далее);
- может быть виртуальным (далее).

### 8. К каким атрибутам имеют доступ методы класса?

**Ответ:** Методы класса имеют неограниченный доступ ко всем элементам класса, независимо от спецификаторов доступа и
порядка объявления методов в классе.

### 9. Что представляет собой указатель this?

**Ответ:** Метод неявно получает в качестве аргумента указатель на тот объект, для которого он вызван. Этот указатель
обозначается ключевым словом this.

### 10. Какая разница между методами определенными внутри класса и вне класса?

**Ответ:** Если метод определяется вне функции, то принадлежность метода классу указывается с помощью имени
класса: `Имя_класса::Имя_метода`. В классе присутствует только прототип.

### 11. Какое значение возвращает конструктор?

**Ответ:** Конструктор не возвращает значение, даже типа void.

### 12. Какие методы создаются по умолчанию?

**Ответ:** Конструктор без параметров и конструктор копирования создаются по умолчанию.

### 13. Какое значение возвращает деструктор?

**Ответ:** Деструктор не возвращает значений.

### 14. Дано описание класса

```
class Student {
    string name;
    int group;

public:
    student(string, int);
    student(const student&)
    ~student();
};
```

Какой метод отсутствует в описании класса?

**Ответ:** Конструктор без параметров

### 15. Какой метод будет вызван при выполнении следующих операторов:

```
student*s;
s=new student;
```

**Ответ:** Конструктор без параметров

### 16. Какой метод будет вызван при выполнении следующих операторов:

```
student s("Ivanov",20);
```

**Ответ:** Конструктор с параметрами

### 17. Какие методы будут вызваны при выполнении следующих операторов:

```
student s1("Ivanov",20);
student s2=s1;
```

**Ответ:** Конструктор с параметрами и конструктор копирования

### 18. Какие методы будут вызваны при выполнении следующих операторов:

```
student s1("Ivanov",20);
student s2;
s2=s1;
```

**Ответ:** Конструктор с параметрами, без параметров, и копирования

### 19. Какой конструктор будет использоваться при передаче параметра в функцию `print()`:

```
void print(student a) { a.show(); }
```

**Ответ:** Конструктор копирования

### 20. Класс описан следующим образом:

```
class Student {
    string name;
    int age;

public:
    void set_name(string);
    void set_age(int);
    ...
};

Student p;
```

Каким образом можно присвоить новое значение атрибуту `name` объекта `р`?

**Ответ:** Для того чтобы присвоить новое значение атрибуту необходимо вызвать метод `set_name()`, изменить атрибут
напрямую не получится так как он нахотся в защищенной области класса.

```
p.set_name("Ivan");
```

[uml-diagram]: ./assets/s2p2.svg "UML Diagram"